diff --git a/AppleIntelWifiAdapter/mvm/IWLMvmDriver.cpp b/AppleIntelWifiAdapter/mvm/IWLMvmDriver.cpp
index e89ce7a..7c620e6 100644
--- a/AppleIntelWifiAdapter/mvm/IWLMvmDriver.cpp
+++ b/AppleIntelWifiAdapter/mvm/IWLMvmDriver.cpp
@@ -18,6 +18,7 @@
 #include "IWLMvmMac.hpp"
 #include "IWLMvmPhy.hpp"
 #include "IWLApple80211.hpp"
+#include "../compat/linux/random.h"
 
 
 #define super OSObject
@@ -550,6 +551,21 @@ bool IWLMvmDriver::enableDevice() {
     }
     
     
+    if(fw_has_capa(&this->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_CAPA_DQA_SUPPORT))
+    {
+        iwl_dqa_enable_cmd cmd = {
+            .cmd_queue = cpu_to_le32(IWL_MVM_DQA_CMD_QUEUE),
+        };
+        
+        u32 cmd_id = iwl_cmd_id(DQA_ENABLE_CMD, DATA_PATH_GROUP, 0);
+        
+        int ret = sendCmdPdu(cmd_id, 0, sizeof(cmd), &cmd);
+        if(ret)
+            IWL_ERR(0, "Failed to send DQA enabling commands: %d\n", ret);
+        else
+            IWL_INFO(0, "Working in DQA mode\n");
+    }
+    
     err = iwl_mvm_add_aux_sta(this);
     if(err < 0) {
         IWL_ERR(0, "Failed to add aux station: %d\n", err);
@@ -565,6 +581,7 @@ bool IWLMvmDriver::enableDevice() {
             goto fail;
     }
     
+    if(!fw_has_capa(&this->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_CAPA_SET_LTR_GEN2))
     {
         iwl_ltr_config_cmd cmd = {
             .flags = htole32(LTR_CFG_FLAG_FEATURE_ENABLE),
@@ -580,10 +597,13 @@ bool IWLMvmDriver::enableDevice() {
     }
     
     
-    err = (this->updateMcc("ZZ", MCC_SOURCE_OLD_FW) == NULL);
-    if(err < 0) {
-        IWL_ERR(0, "Failed to update MCC: %d\n", err);
-        goto fail;
+    if(fw_has_capa(&this->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_CAPA_LAR_SUPPORT)) {
+        err = (this->updateMcc("ZZ", MCC_SOURCE_OLD_FW) == NULL);
+        if(err < 0) {
+            IWL_ERR(0, "Failed to update MCC: %d\n", err);
+            goto fail;
+        }
+        IWL_INFO(0, "LAR Support");
     }
     
     if(fw_has_capa(&this->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {
@@ -847,10 +867,13 @@ int IWLMvmDriver::sendPowerStatus() {
     };
     
     if(!fw_has_capa(&this->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_FLAGS_DEVICE_PS_CMD)) {
+        IWL_INFO(0, "No PS Support");
         return 0;
     }
     
     cmd.flags |= htole16(DEVICE_POWER_FLAGS_CAM_MSK);
+//    cmd.flags |= htole16(DEVICE_POWER_FLAGS_32K_CLK_VALID_MSK);
+//    cmd.flags |= htole16(DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK);
     
     IWL_INFO(0, "Sending power command with flags (0x%0x)\n", cmd.flags);
     
diff --git a/AppleIntelWifiAdapter/mvm/IWLMvmMac.cpp b/AppleIntelWifiAdapter/mvm/IWLMvmMac.cpp
index d535faa..7b0dc74 100644
--- a/AppleIntelWifiAdapter/mvm/IWLMvmMac.cpp
+++ b/AppleIntelWifiAdapter/mvm/IWLMvmMac.cpp
@@ -64,7 +64,8 @@ int iwl_config_umac_scan(IWLMvmDriver* drv) {
     cfg->rx_chains = cpu_to_le32(iwl_mvm_get_valid_rx_ant(drv->m_pDevice));
     cfg->legacy_rates = cpu_to_le32(rates | SCAN_CONFIG_SUPPORTED_RATE(rates));
     
-    if(iwl_mvm_is_cdb_supported(drv->m_pDevice)) {
+    if(iwl_mvm_cdb_scan_api(drv->m_pDevice) && iwl_mvm_is_cdb_supported(drv->m_pDevice)) {
+        IWL_INFO(0, "cfg_v2 scan config being used");
         iwl_scan_config_v2* cfg_v2 = (iwl_scan_config_v2*)cfg;
         cfg_v2->dwell.active = 10;
         cfg_v2->dwell.passive = 110;
@@ -320,7 +321,7 @@ int iwl_umac_scan_fill_channels(IWLMvmDriver* drv, apple80211_scan_data* appleRe
         IWL_DEBUG(0, "adding chan %d to scan\n", c->channel);
         chan->v1.channel_num = htole16(c->channel);
 
-#ifdef notyet
+#ifndef notyet
         if(fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_SCAN_EXT_CHAN_VER)) {
 #else
         if(0) {
@@ -359,8 +360,8 @@ int iwl_umac_scan(IWLMvmDriver* drv, apple80211_scan_data* appleReq) {
     
     
     bool adaptive_dwell = fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_ADAPTIVE_DWELL);
-    //bool ext_chan = fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_SCAN_EXT_CHAN_VER);
-    bool ext_chan = false;
+    bool ext_chan = fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_SCAN_EXT_CHAN_VER);
+    //bool ext_chan = false;
     //bool adaptive_dwell = false;
     
 #ifdef notyet
@@ -420,16 +421,21 @@ int iwl_umac_scan(IWLMvmDriver* drv, apple80211_scan_data* appleReq) {
         req->general_flags |= cpu_to_le32(IWL_UMAC_SCAN_GEN_FLAGS_EXTENDED_DWELL);
     } else {
         req->general_flags |= cpu_to_le32(IWL_UMAC_SCAN_GEN_FLAGS_PROB_REQ_HIGH_TX_RATE);
-        
+        req->general_flags |= cpu_to_le32(IWL_UMAC_SCAN_GEN_FLAGS_ADAPTIVE_DWELL);
     }
     
     int channel_flags;
     channel_flags = 0;
     
-    if (iwl_scan_use_ebs(drv))
+    if (iwl_scan_use_ebs(drv)) {
         channel_flags = IWL_SCAN_CHANNEL_FLAG_EBS |
             IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |
             IWL_SCAN_CHANNEL_FLAG_CACHE_ADD;
+        
+        if(fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_FRAG_EBS)) {
+            channel_flags |= IWL_SCAN_CHANNEL_FLAG_EBS_FRAG;
+        }
+    }
     
     req->scan_start_mac_id = 4;
     
@@ -438,12 +444,34 @@ int iwl_umac_scan(IWLMvmDriver* drv, apple80211_scan_data* appleReq) {
          req->v7.active_dwell = 10;
          req->v7.passive_dwell = 110;
          req->v7.fragmented_dwell = 44;
-         req->v7.adwell_default_n_aps_social = 10;
-         req->v7.adwell_default_n_aps = 2;
+         req->v7.adwell_default_n_aps_social = 10; // IWL_SCAN_ADWELL_DEFAULT_N_APS_SOCIAL
+         req->v7.adwell_default_n_aps = 2; // IWL_SCAN_ADWELL_DEFAULT_LB_N_APS
          req->v7.adwell_max_budget = htole16(300);
          req->v7.scan_priority = htole32(IWL_SCAN_PRIORITY_HIGH);
-         req->v7.channel.flags = channel_flags;
-         req->v7.channel.count = iwl_umac_scan_fill_channels(drv, appleReq, (struct iwl_scan_channel_cfg_umac *)req->v7.data, appleReq->ssid_len != 0);
+         req->v8.channel.flags = channel_flags;
+         req->v8.channel.count = iwl_umac_scan_fill_channels(drv, appleReq, (struct iwl_scan_channel_cfg_umac *)req->v8 .data, appleReq->ssid_len != 0);
+        
+        if (fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_ADWELL_HB_DEF_N_AP)) {
+            req->v9.adwell_default_hb_n_aps = 8; // IWL_SCAN_ADWELL_DEFAULT_HB_N_APS
+        }
+        
+        if (!fw_has_api(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_API_ADAPTIVE_DWELL_V2)) {
+            req->v7.fragmented_dwell = 44; // IWL_SCAN_DWELL_FRAGMENTED
+            req->v7.active_dwell = 10;
+            req->v7.passive_dwell = 110;
+            
+            req->v8.num_of_fragments[0] = 3;
+        } else {
+            req->v8.active_dwell[0] = 10;
+            req->v8.passive_dwell[0] = 110;
+            if(fw_has_capa(&drv->m_pDevice->fw.ucode_capa, IWL_UCODE_TLV_CAPA_CDB_SUPPORT)) {
+                req->v8.active_dwell[1] = 10;
+                req->v8.passive_dwell[1] = 110;
+            }
+            
+            req->v8.general_flags2 = IWL_UMAC_SCAN_GEN_FLAGS2_ALLOW_CHNL_REORDER;
+            IWL_INFO(0, "adaptive v2");
+        }
         
         //req->v7.max_out_time[0] = htole32(120);
         //req->v7.suspend_time[0] = htole32(120);
diff --git a/AppleIntelWifiAdapter/trans/IWLTransport.cpp b/AppleIntelWifiAdapter/trans/IWLTransport.cpp
index 7c9f43e..c4dafe1 100644
--- a/AppleIntelWifiAdapter/trans/IWLTransport.cpp
+++ b/AppleIntelWifiAdapter/trans/IWLTransport.cpp
@@ -164,7 +164,7 @@ bool IWLTransport::init(IWLDevice *device)
         //        IRQF_SHARED, DRV_NAME, trans);
         
         this->inta_mask = CSR_INI_SET_MASK;
-    
+//    iwlWrite32(CSR_INT_MASK, this->inta_mask);
     IWL_ERR(0, "init succeed\n");
     return true;
 }
